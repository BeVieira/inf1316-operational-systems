1) Execute o programa “ctrl-c.c”.
Digite Ctrl-C e Ctrl-\. Analise o resultado.
Neste mesmo programa, remova os
comandos signal( ) e repita o teste anterior
observando os resultados.

-----------------------Código fonte
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#define EVER ;;

void intHandler(int sinal);
void quitHandler(int sinal);

int main (void)
{
    void (*p)(int); // ponteiro para função que recebe int como
    // parâmetro
    p = signal(SIGINT, intHandler);
    printf("Endereco do manipulador anterior %p\n", p);
    p = signal(SIGQUIT, quitHandler);
    printf("Endereco do manipulador anterior %p\n", p);
    puts ("Ctrl-C desabilitado. Use Ctrl-\\ para terminar");
    for(EVER);
}

void intHandler(int sinal)
{
    printf("Você pressionou Ctrl-C (%d) \n", sinal);
}

void quitHandler(int sinal)
{
    printf("Terminando o processo...\n");
    exit (0);
}

----------------------Compilacao
gcc ex1.c -o ex1
./ex1

----------------------Saida
Endereco do manipulador anterior 0x0
Endereco do manipulador anterior 0x0
Ctrl-C desabilitado. Use Ctrl-\ para terminar
^\Terminando o processo...

----------------------Reflexao
Com os manipuladores instalados, o Ctrl-C (SIGINT)
não encerra o processo, apenas imprime uma mensagem, 
e o Ctrl-\ (SIGQUIT) termina de forma controlada.
Sem os signal(), ambos voltam ao comportamento padrão 
do sistema: Ctrl-C mata o processo e Ctrl-\ mata e
ainda gera core dump. Isso mostra como signal()
permite alterar o tratamento padrão dos sinais.

-----------------------2) SIGKILL -----------------------
Tente fazer um programa para interceptar o
sinal SIGKILL. Você conseguiu? Explique.

-----------------------Código fonte
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void handler(int signo) {
    printf("Sinal %d recebido!\n", signo);
    fflush(stdout);
}

int main(void) {
    struct sigaction sa;
    sa.sa_handler = handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGKILL, &sa, NULL);

    printf("PID = %d\n", getpid());
    fflush(stdout);

    while (1) {
        pause();
    }
}

----------------------Compilacao
gcc ex2.c -o ex2
./ex2

----------------------Saida
PID = 2920

----------------------Reflexao
Não é possível interceptar, ignorar ou tratar o SIGKILL.
Esse sinal é reservados pelo kernel justamente para garantir
que um processo possa sempre ser finalizado ou parado pelo
sistema, mesmo que ele tenha bloqueado todos os outros sinais.

-----------------------3) Filhocidio.c  -----------------------
Execute e explique o funcionamento de filhocidio.c

-----------------------Código fonte
filhocidio.c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>

void childhandler(int signo);
int delay;

int main(int argc, char *argv[]) {
    pid_t pid;
    signal(SIGCHLD, childhandler);

    if ((pid = fork()) < 0) {
        fprintf(stderr, "Erro ao criar filho\n");
        exit(-1);
    }

    if (pid == 0) { /* child */
        execve(argv[2], 0, 0); /* ou sleep(3); */
    } else { /* parent */
        sscanf(argv[1], "%d", &delay); /* read delay from command line */
        sleep(delay);
        printf("Program %s exceeded limit of %d seconds!\n", argv[2], delay);
        kill(pid, SIGKILL);
        sleep(1); /* necessary for SIGCHLD to arrive */
    }
    return 0;
}

void childhandler(int signo) { /* Executed if child dies before parent */
    int status;
    pid_t pid = wait(&status);
    printf("Child %d terminated within %d seconds com estado %d.\n", pid, delay, status);
    exit(0);
}

sleep5.c
#include <stdio.h>
#include <unistd.h>
int main (void)
{
    fprintf(stdout, "indo dormir...\n");
    sleep(5);
    fprintf(stdout, "Acordei!\n");
    return 0;
}

sleep15.c
#include <stdio.h>
#include <unistd.h>
int main (void)
{
    fprintf(stdout, "indo dormir...\n");
    sleep(15);
    fprintf(stdout, "Acordei!\n");
    return 0;
}

----------------------Compilacao
gcc filhocidio.c -o filhocidio
gcc sleep5.c -o sleep5
gcc sleep15.c -o sleep15
./filhocidio 10 ./sleep5
./filhocidio 10 ./sleep15

----------------------Saida
Para sleep5:
indo dormir...
Acordei!
Child 4320 terminated within 10 seconds com estado 0.

Para sleep15:
indo dormir...
Program ./sleep15 exceeded limit of 10 seconds!
Child 4412 terminated within 10 seconds com estado 9.

----------------------Reflexao
O programa cria um processo filho e seu pai controlador,
limita seu tempo de execução. Se o filho terminar antes
do limite, o pai recebe SIGCHLD e informa o fim normal. 
Caso ultrapasse o tempo, o pai envia SIGKILL e encerra à
força. Assim, o código exemplifica como monitorar e
controlar a execução de processos com sinais.

-----------------------4) SIGSTOP e SIGCONT -----------------------
Usando SIGSTOP e SIGCONT faça um programa que crie 
2 processos filho e alterne a execução dos filhos.
Após 10 trocas de contexto, o processo pai mata os 
processos filho.
OBS: Os processos filho são formados por loops infinitos.

-----------------------Código fonte
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

int main(void) {
    pid_t f1, f2;

    if ((f1 = fork()) == 0) {
        while (1) {
            printf("Filho 1 em execução...\n");
            fflush(stdout);
            sleep(1);
        }
    }

    if ((f2 = fork()) == 0) {
        while (1) {
            printf("Filho 2 em execução...\n");
            fflush(stdout);
            sleep(1);
        }
    }

    
    sleep(1);            
    kill(f1, SIGSTOP);    
    int i;
    for (i = 0; i < 10; i++) {
        kill(f2, SIGCONT);
        sleep(1);
        kill(f2, SIGSTOP); 

        kill(f1, SIGCONT); 
        sleep(1);
        kill(f1, SIGSTOP); 
    }

    kill(f1, SIGKILL);
    kill(f2, SIGKILL);

    wait(NULL);
    wait(NULL);

    printf("Pai finalizou os filhos após 10 trocas.\n");
    return 0;
}

----------------------Compilacao
gcc ex4.c -o ex4
./ex4

----------------------Saida
Filho 1 em execução...
Filho 2 em execução...
Filho 1 em execução...
Filho 2 em execução...
Filho 2 em execução...
Filho 1 em execução...
Filho 1 em execução...
Filho 2 em execução...
Filho 2 em execução...
Filho 1 em execução...
Filho 1 em execução...
Filho 2 em execução...
Filho 2 em execução...
Filho 1 em execução...
Filho 2 em execução...
Filho 2 em execução...
Filho 1 em execução...
Filho 1 em execução...
Filho 2 em execução...
Filho 2 em execução...
Filho 1 em execução...
Filho 2 em execução...
Filho 2 em execução...
Filho 1 em execução...
Filho 2 em execução...
Filho 2 em execução...
Filho 1 em execução...
Filho 2 em execução...
Filho 2 em execução...
Filho 1 em execução...
Filho 1 em execução...
Filho 2 em execução...
Filho 1 em execução...
Filho 2 em execução...
Filho 1 em execução...
Filho 1 em execução...
Pai finalizou os filhos após 10 trocas.

----------------------Reflexao
O programa demonstra o uso de SIGSTOP e SIGCONT para 
alternar a execução de dois filhos em loop infinito.
O pai atua como escalonador simples, controlando os
turnos de cada processo. Após 10 trocas, envia SIGKILL
e encerra os filhos.
