5) Faça um programa que leia 2 números e
imprima o resultado das 4 operações básicas
sobre estes 2 números.
- Verifique o que acontece se o 2º. número
da entrada for 0 (zero)
- Capture o sinal de erro de floating point
(SIGFPE) e repita a experiência anterior

-----------------------Código fonte
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>

void trataDivisaoPorZero(int sinal);

int main (int argc, char *argv[]) {
    if (argc != 3) {
        printf("Uso: %s <num1> <num2>\n", argv[0]);
        return 1;
    }
    
    int num1 = atoi(argv[1]);
    int num2 = atoi(argv[2]);

    signal(SIGFPE, trataDivisaoPorZero);
    
    printf("Soma: %d + %d = %d\n", num1, num2, num1 + num2);
    printf("Subtração: %d - %d = %d\n", num1, num2, num1 - num2);
    printf("Multiplicação: %d * %d = %d\n", num1, num2, num1 * num2);
    
    printf("Divisão: %d / %d = ", num1, num2);
    printf("%d\n", num1 / num2);

    return 0;
}

void trataDivisaoPorZero(int sinal) {
    printf("Erro: Divisão por zero não é permitida.\n");
    exit(1);
}   
----------------------Compilacao
gcc ex5.c -o ex5
./ex5 2 1
./ex5 2 0
----------------------Saida
Para 2 1:
Soma: 2 + 1 = 3
Subtração: 2 - 1 = 1
Multiplicação: 2 * 1 = 2
Divisão: 2 / 1 = 2

Para 2 0 sem a trativa do sinal:
Soma: 2 + 0 = 2
Subtração: 2 - 0 = 2
Multiplicação: 2 * 0 = 0
Divisão: 2 / 0 = 
Floating point exception (core dumped)

Para 2 0:
Soma: 2 + 0 = 2
Subtração: 2 - 0 = 2
Multiplicação: 2 * 0 = 0
Divisão: 2 / 0 = Erro: Divisão por zero não é permitida.

----------------------Reflexao
Sem a tratativa do sinal, o programa executa normalmente até o ponto
em que ocorre a divisão por zero. Nesse momento, o sistema operacional
envia o sinal SIGFPE ao processo, que é encerrado de imediatamente.
Com a tratativa implementada, quando o erro ocorre, o programa não é
encerrado imediatamente pelo SO. Em vez disso, a função tratadora é executada,
exibindo a mensagem de erro e encerrando o programa de forma controlada com exit(1).

-----------------------6) Monitorar Chamadas telefonicas-----------------------
Faça um programa para monitorar e informar o
preço de chamadas telefônicas. O programa
deverá ser executado em background.
- O início e o término de uma chamada são
informados através dos sinais SIGUSR1 e
SIGUSR2, respectivamente.
- O custo da ligação é de 2 centavos por
segundo, para ligações de até 1 minuto ou de 1
centavo por segundo a partir do 2º. minuto, ou
seja, uma ligação de 1m30s custa R$1,50.

-----------------------Código fonte

#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <time.h>

#define EVER ;;

static volatile sig_atomic_t start_flag = 0;
static volatile sig_atomic_t stop_flag = 0;
static volatile sig_atomic_t exit_flag = 0;
static enum { IDLE=0, IN_CALL=1 } state = IDLE;
static struct timespec t_start;

void set_flag(int signo) {
    if (signo == SIGUSR1) start_flag = 1;
    else if (signo == SIGUSR2) stop_flag = 1;
    else if (signo == SIGTERM || signo == SIGINT) exit_flag = 1;
}

long diff_seconds(struct timespec a, struct timespec b) {
    long sec = b.tv_sec - a.tv_sec;
    long nsec = b.tv_nsec - a.tv_nsec;
    if (nsec < 0) { sec -= 1; nsec += 1000000000L; }
    return sec;
}

void compute_and_print_price(long secs) {
    long first = secs > 60 ? 60 : secs;
    long rest  = secs > 60 ? secs - 60 : 0;
    long cents = first * 2 + rest * 1;
    long reais = cents / 100;
    long centavos = cents % 100;
    printf("Ligação encerrada: duração = %lds | Preço = R$%ld,%02ld\n", secs, reais, centavos);
    fflush(stdout);
}

int main(void) {
    struct sigaction sa;
    sa.sa_handler = set_flag;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sigaction(SIGUSR1, &sa, NULL);
    sigaction(SIGUSR2, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGINT,  &sa, NULL);

    fflush(stdout);

    for(EVER) {
        pause();
        if (exit_flag) exit(0);
        if (start_flag) {
            start_flag = 0;
            if (state == IDLE) {
                clock_gettime(CLOCK_MONOTONIC, &t_start);
                state = IN_CALL;
                printf("Chamada iniciada\n");
                fflush(stdout);
            }
        }
        if (stop_flag) {
            stop_flag = 0;
            if (state == IN_CALL) {
                struct timespec now;
                clock_gettime(CLOCK_MONOTONIC, &now);
                long secs = diff_seconds(t_start, now);
                compute_and_print_price(secs);
                state = IDLE;
            }
        }
    }
}

----------------------Compilacao
gcc ex5.c -o ex5
./ex6 &   
kill -s SIGUSR1 $(pgrep -n ex6)
sleep 75
kill -s SIGUSR2 $(pgrep -n ex6)

./ex6 &   
kill -s SIGUSR1 $(pgrep -n ex6)
sleep 10
kill -s SIGUSR2 $(pgrep -n ex6)

----------------------Saida

Para sleep 75:

Chamada iniciada
Ligação encerrada: duração = 75s | Preço = R$1,35

Para sleep 10:

Chamada iniciada
Ligação encerrada: duração = 10s | Preço = R$0,20

----------------------Reflexao

O código implementa o monitoramento solicitado 
no enunciado, utilizando os sinais SIGUSR1 e SIGUSR2 para marcar 
o início e o fim das chamadas. 
A função que calcula o tempo usa CLOCK_MONOTONIC, 
garantindo precisão na medição, e a tarifação é feita de acordo com 
a regra: 2 centavos por segundo até 60 segundos 
e 1 centavo por segundo a partir do segundo minuto. 