1) Faça um programa para criar dois processos que se comunicam via pipe. O Pai lê do pipe
enquanto o filho escreve no pipe. Exiba o resultado do que foi escrito e lido.

-----------------------Código fonte
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(int argc, char *argv[])
{
	int pipefd[2];
	pid_t pid;
	char buffer[100];
	int bytes_read;

	if (pipe(pipefd) == -1) {
		perror("pipe");
		return 1;
	}

	pid = fork();
	if (pid == -1) {
		perror("fork");
		return 1;
	}

	if (pid == 0)
	{
		close(pipefd[0]);
		write(pipefd[1], "Salve paizao!\n", 13);
		close(pipefd[1]);
		return 0;
	}

	close(pipefd[1]);
	bytes_read = read(pipefd[0], buffer, 100);
	printf("Pai lendo bytes do filho: %d\n", bytes_read);
	printf("Filhao: %s\n", buffer);
	close(pipefd[0]);

	return 0;
}

----------------------Compilacao
gcc ex1.c -o ex1
./ex1

----------------------Saida
Pai lendo bytes do filho: 13
Filhao: Salve paizao!

----------------------Reflexao
A comunição entre processos é feita através de pipes. Uma pipe é uma conexão
bidirecional de arquivos. O processo pai lê do pipe enquanto o processo filho escreve no pipe.

-----------------------2) Redirecionar a entrada e a saída-----------------------
Faça um programa para redirecionar a entrada e a saída, lendo os dados de um arquivo
e gerando a saída em outro.

-----------------------Código fonte
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>
 
int main() {
    int pipefd[2];
    pid_t pid;
    char buffer[1024];
 
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }
 
    pid = fork();
 
    if (pid < 0) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
 
    if (pid > 0) {
        // Processo PAI
        close(pipefd[0]);
 
        FILE *entrada = fopen("entrada.txt", "r");
        if (entrada == NULL) {
            perror("fopen entrada.txt");
            exit(EXIT_FAILURE);
        }
 
        while (fgets(buffer, sizeof(buffer), entrada) != NULL) {
            write(pipefd[1], buffer, strlen(buffer));
        }
 
        fclose(entrada);
        close(pipefd[1]); 
 
        wait(NULL);
 
    } else {
        // Processo FILHO
        close(pipefd[1]);
 
        FILE *saida = fopen("saida.txt", "w");
        if (saida == NULL) {
            perror("fopen saida.txt");
            exit(EXIT_FAILURE);
        }
 
        dup2(pipefd[0], STDIN_FILENO);
 
        close(pipefd[0]);
 
        while (fgets(buffer, sizeof(buffer), stdin) != NULL) {
            fprintf(saida, "%s", buffer);
        }
 
        fclose(saida);
        exit(EXIT_SUCCESS);
    }
 
    return 0;
}

----------------------Compilacao
gcc ex2.c -o ex2
./ex2 | cat saida.txt

----------------------Saida
Este arquivo será redirecionado pelo programa ex2.c

----------------------Reflexao
Esse exercício me ajudou a entender como funciona a comunicação
entre processos no Linux usando pipe() e fork(). No código, o
processo pai lê os dados de um arquivo e envia pelo pipe, enquanto
o filho redireciona a entrada padrão para o pipe e grava os dados recebidos
em outro arquivo. Foi interessante ver como o redirecionamento com dup2()
permite que o filho “escute” o que o pai envia, como se fosse a entrada
normal do programa. Na prática, consegui aplicar conceitos de processos,
redirecionamento e manipulação de arquivos de forma integrada.

-----------------------3) Executar 2 processos-----------------------
Faça um programa para criar um pipe e executar dois processos que são
utilitários do Unix que se comuniquem através do pipe criado, assim
como a shell faz 

-----------------------Código fonte
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    int fd[2];
    pid_t pid1, pid2;

    if (pipe(fd) == -1) {
        perror("pipe");
        exit(1);
    }

    // Criar o primeiro processo (produtor: ps)
    pid1 = fork();
    if (pid1 < 0) {
        perror("fork");
        exit(1);
    }

    if (pid1 == 0) {
        // Processo filho 1
        dup2(fd[1], STDOUT_FILENO);
        close(fd[0]);
        close(fd[1]);

        execlp("ps", "ps", NULL);
        perror("execlp ps");
        exit(1);
    }

    // Criar o segundo processo (consumidor: wc)
    pid2 = fork();
    if (pid2 < 0) {
        perror("fork");
        exit(1);
    }

    if (pid2 == 0) {
        // Processo filho 2
        dup2(fd[0], STDIN_FILENO);
        close(fd[1]); 
        close(fd[0]); 

        execlp("wc", "wc", NULL);
        perror("execlp wc");
        exit(1);
    }

    close(fd[0]);
    close(fd[1]);

    wait(NULL);
    wait(NULL);

    return 0;
}

----------------------Compilacao
gcc ex3.c -o ex3
./ex3

----------------------Saida
5      20     149

----------------------Reflexao

-----------------------4) Dois processos leitores-----------------------
Faça um programa que cria dois processos leitores e um processo escritor
em uma mesma pipe. Faça o escritor dormir metade do tempo dos leitores,
e mostre como os leitores consomem os dados produzidos pelo escritor.
Obs: não force uma alternância controlada por
SIGSTOP/SIGCONT.

-----------------------Código fonte
O programa simula um pipe da shell. Primeiro ele cria um canal de comunicação
com pipe(). Depois, com dois fork(), um processo executa o ps e escreve no pipe,
enquanto o outro executa o wc e lê do pipe. Assim, a saída de um vira a entrada
do outro, do mesmo jeito que acontece quando usamos ps | wc no terminal.

----------------------Compilacao

----------------------Saida

----------------------Reflexao