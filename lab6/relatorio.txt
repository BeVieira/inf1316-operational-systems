
-----------------------1) Comunicação entre dois processos usando FIFO---------------------------
Abra duas seções de terminais:
- Na primeira, execute um programa que fica em
loop lendo de uma FIFO para depois escrever na
saída padrão (tela)
- Na segunda, execute um programa que fica lendo
da entrada padrão (teclado) e depois escreve na
mesma FIFO 

-----------------------Código fonte
ex1-leitor.c:

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

#define FIFO_NOME "minhaFifo"

int main() {
    int fd;
    char buffer[1024];
    int bytes_lidos;

    if (mkfifo(FIFO_NOME, S_IRUSR | S_IWUSR) == -1) {
        perror("mkfifo");
    }

    printf("Aguardando um escritor...\n");
    
    fd = open(FIFO_NOME, O_RDONLY);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    printf("Leitor pronto. Lendo mensagens da FIFO:\n");

    while ((bytes_lidos = read(fd, buffer, sizeof(buffer) - 1)) > 0) {
        buffer[bytes_lidos] = '\0';
        printf("Recebido: %s", buffer);
    }

    close(fd);
    unlink(FIFO_NOME);

    return 0;
}

ex1-escritor.c:

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

#define FIFO_NOME "minhaFifo"

int main() {
    int fd;
    char buffer[1024];

    fd = open(FIFO_NOME, O_WRONLY);
    if (fd == -1) {
        perror("open");
        return 1;
    }
    
    printf("Escritor pronto. Digite suas mensagens (Ctrl+D para sair):\n");

    while (fgets(buffer, sizeof(buffer), stdin) != NULL) {
        write(fd, buffer, strlen(buffer));
    }

    printf("\nSaindo do escritor.\n");
    close(fd);

    return 0;
}
----------------------Compilacao
gcc -o leitor ex1-leitor.c
gcc -o escritor ex1-escritor.c

----------------------Saida

Terminal 1 (leitor):
$ ./leitor
Aguardando um escritor...
Leitor pronto. Lendo mensagens da FIFO:
Recebido: alo
Recebido: Tudo bem?
Recebido: Como você se chama?


Terminal 2 (escritor):
$ ./escritor
Escritor pronto. Digite suas mensagens (Ctrl+D para sair):
alo 
Tudo bem?
Como você se chama?
^D (Ctrl+D)
Saindo do escritor.

----------------------Reflexao
A comunicação é feita via FIFO, um tipo especial de arquivo 
visível no sistema de arquivos que permite 
a comunicação entre dois processos quaisquer. 
O processo escritor envia dados para o arquivo FIFO, 
enquanto o leitor lê os dados deste mesmo arquivo.


-----------------------2) Comunicação entre pai e filhos usando FIFO---------------------------
Escreva um programa que primeiro cria
uma FIFO e em seguida cria dois processos
filho que escrevem uma string na FIFO.
O pai dá um waitpid em seguida lê as
strings desse FIFO e exibe na tela.

-----------------------Código fonte
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <sys/wait.h>

#define FIFO_NOME "minhaFifoEx2"

int main() {
    pid_t pid1, pid2;
    int fd;
    char buffer[1024];

    mkfifo(FIFO_NOME, S_IRUSR | S_IWUSR);

    pid1 = fork();
    if (pid1 == 0) { 
        fd = open(FIFO_NOME, O_WRONLY);
        char msg[] = "Opa, meu amigo, eu sou o filho 1.\n";
        write(fd, msg, strlen(msg));
        close(fd);
        exit(0);
    }

    pid2 = fork();
    if (pid2 == 0) {
        fd = open(FIFO_NOME, O_WRONLY);
        char msg[] = "Fala, meu parceiro, eu sou o filho 2.\n";
        write(fd, msg, strlen(msg));
        close(fd);
        exit(0);
    }
    
    fd = open(FIFO_NOME, O_RDONLY);

    waitpid(pid1, NULL, 0);
    waitpid(pid2, NULL, 0);

    int bytes_lidos = read(fd, buffer, sizeof(buffer) - 1);
    buffer[bytes_lidos] = '\0';
    printf("Pai leu da FIFO o seguinte conteudo:\n%s", buffer);
    
    close(fd);
    unlink(FIFO_NOME);

    return 0;
}

----------------------Compilacao
gcc ex2.c -o ex2
./ex2

----------------------Saida
$ ./ex2
Pai leu da FIFO o seguinte conteudo:
Opa, meu amigo, eu sou o filho 1.
Fala, meu parceiro, eu sou o filho 2.

----------------------Reflexao
A FIFO é utilizada como canal de comunicação entre 
um processo pai e seus filhos. Os filhos escrevem 
na FIFO e o pai lê os dados. A sincronização é feita com 
waitpid para garantir que o pai leia apenas após a 
conclusão da escrita pelos filhos.


-----------------------3) Comunicação cliente-servidor com duas FIFOs-----------------------
Escreva um servidor e um cliente usando duas
FIFOs: uma para enviar strings para o servidor,
e outra para transmitir as respostas de volta
para os clientes. O servidor deverá rodar em
background e transformar cada palavra
recebida de minusculas para maiúsculas. 

-----------------------Código fonte
servidor.c:
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <ctype.h>

#define FIFO_SERVIDOR "servidor_fifo"

typedef struct
{
  pid_t pid_cliente;
  char texto[256];
} Mensagem;

int main()
{
  int fd_leitura, fd_cliente;
  Mensagem msg;
  char fifo_cliente_nome[50];

  unlink(FIFO_SERVIDOR);
  if (mkfifo(FIFO_SERVIDOR, S_IRUSR | S_IWUSR) == -1)
  {
    perror("mkfifo");
    return 1;
  }

  printf("Servidor online. Use Ctrl+C para encerrar.\n");

  while (1)
  {
    fd_leitura = open(FIFO_SERVIDOR, O_RDONLY);
    if (fd_leitura == -1)
    {
      perror("open (leitura)");
      return 1;
    }

    printf("Aguardando cliente...\n");

    ssize_t bytes_lidos;
    while ((bytes_lidos = read(fd_leitura, &msg, sizeof(Mensagem))) > 0)
    {
      printf("Servidor recebeu de [%d]: %s\n", msg.pid_cliente, msg.texto);
      for (int i = 0; msg.texto[i]; i++)
      {
        msg.texto[i] = toupper(msg.texto[i]);
      }

      sprintf(fifo_cliente_nome, "cliente_%d_fifo", msg.pid_cliente);
      fd_cliente = open(fifo_cliente_nome, O_WRONLY);
      if (fd_cliente != -1)
      {
        write(fd_cliente, &msg, sizeof(Mensagem));
        close(fd_cliente);
      }
    }

    close(fd_leitura);
    printf("Cliente desconectado. Servidor reiniciando...\n");
  }

  return 0;
}

cliente.c:

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

#define FIFO_SERVIDOR "servidor_fifo"

typedef struct
{
  pid_t pid_cliente;
  char texto[256];
} Mensagem;

int main()
{
  int fd_servidor_escrita, fd_cliente_leitura;
  Mensagem msg;
  char fifo_cliente_nome[50];

  msg.pid_cliente = getpid();
  sprintf(fifo_cliente_nome, "cliente_%d_fifo", msg.pid_cliente);

  unlink(fifo_cliente_nome);
  if (mkfifo(fifo_cliente_nome, S_IRUSR | S_IWUSR) == -1)
  {
    perror("mkfifo cliente");
    return 1;
  }

  fd_servidor_escrita = open(FIFO_SERVIDOR, O_WRONLY);
  if (fd_servidor_escrita == -1)
  {
    perror("Servidor nao esta em execucao");
    unlink(fifo_cliente_nome);
    return 1;
  }

  printf("Cliente conectado. Digite uma mensagem ou pressione Ctrl+D para encerrar.\n");

  while (1)
  {
    printf("> ");
    if (fgets(msg.texto, sizeof(msg.texto), stdin) == NULL)
    {
      printf("\nDetectado Ctrl+D. ");
      break;
    }
    msg.texto[strcspn(msg.texto, "\n")] = 0;

    write(fd_servidor_escrita, &msg, sizeof(Mensagem));

    fd_cliente_leitura = open(fifo_cliente_nome, O_RDONLY);
    if (fd_cliente_leitura == -1)
    {
      perror("open cliente fifo leitura");
      break;
    }

    if (read(fd_cliente_leitura, &msg, sizeof(Mensagem)) > 0)
    {
      printf("Servidor: %s\n", msg.texto);
    }
    else
    {
      printf("Erro ao ler resposta do servidor.\n");
      close(fd_cliente_leitura);
      break;
    }

    close(fd_cliente_leitura);
  }

  printf("Encerrando cliente.\n");
  close(fd_servidor_escrita);
  unlink(fifo_cliente_nome);

  return 0;
}

----------------------Compilacao
gcc -o servidor servidor.c
gcc -o cliente cliente.c

----------------------Execucao
Terminal 1 (servidor):
$ ./servidor
Servidor online. Use Ctrl+C para encerrar.
Aguardando cliente...
Servidor recebeu de [6590]: alo
Cliente desconectado. Servidor reiniciando...
Aguardando cliente...
Servidor recebeu de [6695]: Eu sou o mestre que ta usando o terminal 1
Servidor recebeu de [6653]: eu sou o iniciante do terminal 2
Cliente desconectado. Servidor reiniciando...
^C

Terminal 2 (cliente):
$ ./cliente
Cliente conectado. Digite uma mensagem ou pressione Ctrl+D para encerrar.
> Eu sou o mestre que ta usando o terminal 1
Servidor: EU SOU O MESTRE QUE TA USANDO O TERMINAL 1
> 
Detectado Ctrl+D. Encerrando cliente.

Terminal 3 (cliente):
$ ./cliente
Cliente conectado. Digite uma mensagem ou pressione Ctrl+D para encerrar.
> eu sou o iniciante do terminal 2
Servidor: EU SOU O INICIANTE DO TERMINAL 2
> 
Detectado Ctrl+D. Encerrando cliente.

----------------------Reflexao
O servidor cria uma FIFO pública para receber mensagens dos clientes.
Cada cliente cria sua própria FIFO privada para receber respostas do servidor.
O servidor lê mensagens da FIFO pública, processa (converte para maiúsculas)
e envia a resposta de volta para a FIFO privada do cliente.
A comunicação é bidirecional e permite múltiplos clientes se conectarem ao servidor.