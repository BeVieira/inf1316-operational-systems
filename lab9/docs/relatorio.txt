-----------------------1) Lista Arquivo-----------------------
Use o programa listaarquivo.c para imprimir o
numero de inode, o tamanho (em bytes) e a idade em
dias de cada arquivo do diretório corrente. Lembre-se
que stat() espera o path completo do arquivo

-----------------------Código fonte
#include <sys/types.h>
#include <sys/dir.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

extern int alphasort();
char pathname[MAXPATHLEN];

int file_select(struct direct *entry) {
  if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
    return 0;
  else
    return 1;
}

int main() {
  int count, i;
  struct direct **files;

  if (getwd(pathname) == NULL) {
    printf("Error getting path\n");
    exit(1);
  }

  printf("Current Working Directory = %s\n", pathname);
  count = scandir(pathname, &files, file_select, alphasort);

  if (count <= 0) {
    printf("No files in this directory\n");
    exit(0);
  }

  printf("Number of files = %d\n", count);
  printf("---------------------------------------------------------------\n");
  printf("%-25s %-10s %-10s %-10s\n", "File", "Inode", "Size(bytes)", "Age(days)");
  printf("---------------------------------------------------------------\n");

  for (i = 0; i < count; i++) {
    char fullpath[MAXPATHLEN];
    struct stat info;
    time_t now = time(NULL);

    sprintf(fullpath, "%s/%s", pathname, files[i]->d_name);

    if (stat(fullpath, &info) == 0) {
      double age_days = difftime(now, info.st_mtime) / (60 * 60 * 24);
      printf("%-25s %-10lu %-10ld %-10.1f\n",
              files[i]->d_name,
              (unsigned long) info.st_ino,
              (long) info.st_size,
              age_days);
    } else {
      perror("stat");
    }

    free(files[i]);
  }

  free(files);
  return 0;
}


----------------------Compilacao
gcc -o listaarquivo listaarquivo.c 
./listaarquivo

----------------------Saida
Current Working Directory = /home/bernardo/puc/inf1316-operational-systems/lab9
Number of files = 4
---------------------------------------------------------------
File                      Inode      Size(bytes) Age(days) 
---------------------------------------------------------------
README.md                 51439      694        48.9    //Arquivo de outro diretorio movido para ver um Age > 0  
listaarquivo              62903      16568      0.0       
listaarquivo.c            38605      1562       0.0       
relatorio.txt             36994      1955       0.0   

----------------------Reflexao
O programa original apenas listava os nomes dos
arquivos do diretório, mas não mostrava informações
detalhadas sobre eles. A principal limitação era que
ele usava scandir() para listar os arquivos, porém
não chamava stat(), que é a função responsável por obter
dados como tamanho, número de inode e tempo de modificação.
Além disso, faltava tratar corretamente o caminho completo do
arquivo, o que é essencial para que stat() funcione.

Depois das alterações, o código passou a construir o caminho
completo de cada arquivo, usar stat() para coletar as informações
e calcular a idade em dias a partir da diferença entre o tempo
atual e a última modificação. Assim, o programa não só lista os
arquivos, mas também apresenta dados úteis sobre cada um, cumprindo
o objetivo proposto.

-----------------------2) Número de links-----------------------
2. Modifique o programa anterior para mostrar o número de links que cada arquivo
possui. Depois, no diretório corrente, execute o o comando da shell ln <arquivo>
<nomeLink> e veja o que mudou na saída de seu programa

-----------------------Código fonte
#include <sys/types.h>
#include <sys/dir.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

extern int alphasort();
char pathname[MAXPATHLEN];

int file_select(struct direct *entry) {
  if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
    return 0;
  else
    return 1;
}

int main() {
  int count, i;
  struct direct **files;

  if (getwd(pathname) == NULL) {
    printf("Error getting path\n");
    exit(1);
  }

  printf("Current Working Directory = %s\n", pathname);
  count = scandir(pathname, &files, file_select, alphasort);

  if (count <= 0) {
    printf("No files in this directory\n");
    exit(0);
  }

  printf("Number of files = %d\n", count);
  printf("--------------------------------------------------------------------------\n");
  printf("%-25s %-10s %-10s %-10s %-10s\n", "File", "Inode", "Size", "Links", "Age(days)");
  printf("--------------------------------------------------------------------------\n");

  for (i = 0; i < count; i++) {
      char fullpath[MAXPATHLEN];
      struct stat info;
      time_t now = time(NULL);

      sprintf(fullpath, "%s/%s", pathname, files[i]->d_name);

      if (stat(fullpath, &info) == 0) {
        double age_days = difftime(now, info.st_mtime) / (60 * 60 * 24);
        printf("%-25s %-10lu %-10ld %-10lu %-10.1f\n",
                files[i]->d_name,
                (unsigned long) info.st_ino,
                (long) info.st_size,
                (unsigned long) info.st_nlink,
                age_days);
      } else {
        perror("stat");
      }

    free(files[i]);
  }

  free(files);
  return 0;
}

----------------------Compilacao
gcc -o listaarquivo listaarquivo2.c 
./listaarquivo
ln listaarquivo2.c linkDoPrograma

----------------------Saida
Current Working Directory = /home/bernardo/puc/inf1316-operational-systems/lab9
Number of files = 4
--------------------------------------------------------------------------
File                      Inode      Size       Links      Age(days) 
--------------------------------------------------------------------------
listaarquivo              62903      16568      1          0.0       
listaarquivo.c            38605      1562       1          0.0       
listaarquivo2.c           62891      1673       1          0.0       
relatorio.txt             36994      5485       1          0.0  

> Após executar o comando

Current Working Directory = /home/bernardo/puc/inf1316-operational-systems/lab9
Number of files = 5
--------------------------------------------------------------------------
File                      Inode      Size       Links      Age(days) 
--------------------------------------------------------------------------
linkDoPrograma            62891      1673       2          0.0       
listaarquivo              62903      16568      1          0.0       
listaarquivo.c            38605      1562       1          0.0       
listaarquivo2.c           62891      1673       2          0.0       
relatorio.txt             36994      5485       1          0.0  
----------------------Reflexao
Depois da modificação, o programa passou a mostrar também o número
de links de cada arquivo, obtido com o campo st_nlink da estrutura
stat. Esse número indica quantos nomes (entradas de diretório)
apontam para o mesmo arquivo físico no disco.

Quando eu crio um link com o comando os dois passam a compartilhar
o mesmo inode. Ao rodar o programa novamente, dá pra ver que o valor
de “Links” aumentou de 1 para 2, mostrando que agora existem dois
caminhos diferentes apontando para o mesmo conteúdo. Isso deixa
claro que links não são cópias, mas apenas outros nomes para o
mesmo arquivo real.

-----------------------3) Diretório recursivamente-----------------------
Escreva um programa que percorre recursivamente um diretório, a partir do
diretório corrente, somando o tamanho de todos os arquivos encontrados.

-----------------------Código fonte
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>
#include <limits.h>
#include <string.h>

#define PATH_MAX 4096


long long soma_dir(const char *path) {
    DIR *dir;
    struct dirent *entry;
    struct stat st;
    char fullpath[PATH_MAX];
    long long total = 0;

    dir = opendir(path);
    if (!dir) {
        perror(path);
        return 0;
    }

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 ||
            strcmp(entry->d_name, "..") == 0) {
            continue;
        }

        snprintf(fullpath, sizeof(fullpath), "%s/%s", path, entry->d_name);

        if (stat(fullpath, &st) == -1) {
            perror("stat");
            continue;
        }

        if (S_ISDIR(st.st_mode)) { /*subdiretório*/
            total += soma_dir(fullpath);
        } else if (S_ISREG(st.st_mode)) { /*arquivo regular*/
            total += st.st_size;
        } else { /*outro tipo de arquivo*/
            continue;
        }
    }

    closedir(dir);
    return total;
}

int main(void) {
    char path[PATH_MAX];

    if (getcwd(path, sizeof(path)) == NULL) {
        perror("getcwd");
        return 1;
    }

    printf("Diretório inicial: %s\n", path);

    long long total = soma_dir(path);

    printf("Tamanho total dos arquivos (bytes): %lld\n", total);

    return 0;
}

----------------------Compilacao

gcc -o ex3 ex3.c

----------------------Saida

jvsfrancisco@note-jv:~/projects/inf1316-operational-systems/lab9$ ./ex3
Diretório inicial: /home/jvsfrancisco/projects/inf1316-operational-systems/lab9
Tamanho total dos arquivos (bytes): 29356

----------------------Reflexao

A função recursiva soma_dir faz um percurso em profundidade 
na árvore de diretórios: para cada entrada, se for um subdiretório, 
chama a si mesma; se for arquivo regular, soma st_size.
O valor final é parecido com o que utilitários como du calculam.
O resultado muda conforme o que existe no diretório: se eu criar 
ou apagar arquivos, ou mudar o conteúdo, o valor somado também muda.

-----------------------4) Aninhamento de diretório e arquivos-----------------------
Modifique o programa anterior para mostrar recursivamente os diretórios e arquivos
aninhados.

Dica: use printf(“%*s[%s]\n”,level, “”,entry->dname) para imprimir com a identação
correspondente ao nivel de
recursão 

-----------------------Código fonte

#include <stdio.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>

#define PATH_MAX 4096

void print_tree(const char *path, const char *prefix) {
    DIR *dir = opendir(path);
    if (!dir) {
        perror(path);
        return;
    }

    struct dirent *entry;
    int total = 0;

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 ||
            strcmp(entry->d_name, "..") == 0) {
            continue;
        }
        total++;
    }

    rewinddir(dir);

    int idx = 0;

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 ||
            strcmp(entry->d_name, "..") == 0) {
            continue;
        }

        idx++;
        int is_last = (idx == total);

        printf("%s%s%s\n",
               prefix,
               is_last ? "└── " : "├── ",
               entry->d_name);

        char child_path[PATH_MAX];
        struct stat st;

        sprintf(child_path, "%s/%s", path, entry->d_name);

        if (stat(child_path, &st) == -1) {
            perror("stat");
            continue;
        }

        if (S_ISDIR(st.st_mode)) {
            char new_prefix[PATH_MAX];
            sprintf(new_prefix, "%s%s",
                    prefix,
                    is_last ? "    " : "│   ");

            print_tree(child_path, new_prefix);
        }
    }

    closedir(dir);
}

int main(void) {
    char path[PATH_MAX];

    if (getcwd(path, sizeof(path)) == NULL) {
        perror("getcwd");
        return 1;
    }

    printf("%s\n", path);
    print_tree(path, "");

    return 0;
}

----------------------Compilacao

gcc -Wall -Wextra -o ex4 ex4.c

----------------------Saida

jvsfrancisco@note-jv:~/projects/inf1316-operational-systems/lab9$ ./ex4
/home/jvsfrancisco/projects/inf1316-operational-systems/lab9
├── ex4.c
├── listaarquivo.c
├── ex3.c
├── ex4
├── docs
│   └── relatorio.txt
└── listaarquivo2.c

----------------------Reflexao
A partir do diretório atual, o programa imprime o nome do diretório raiz 
e depois chama lista_dir recursivamente.A cada nível de recursão, 
a indentação aumenta (level * 2 espaços), o que cria uma visualização em 
árvore da estrutura de diretórios. Isso ajuda a enxergar como os 
diretórios se aninham e como o sistema de arquivos é uma árvore, 
conceito importante quando pensamos em percursos recursivos e na 
implementação de comandos como tree.